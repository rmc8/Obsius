/**
 * Dynamic Instruction Formatter Node - Converts AI insights to structured markdown
 * 
 * This node takes the semantic analysis and dynamic instructions generated by
 * DynamicInstructionGeneratorNode and formats them into a comprehensive,
 * readable markdown document that serves as true AI instructions for vault operations.
 * 
 * Unlike static templates, this generates completely dynamic content based on
 * actual vault analysis, ensuring each generated instruction set is unique
 * and specifically tailored to the vault's content and patterns.
 */

import { App } from 'obsidian';
import { ToolRegistry } from '../../tools/ToolRegistry';
import { AnalysisNode, AnalysisData, AnalysisProgress } from './VaultAnalysisWorkflow';

/**
 * Formatted instruction sections
 */
export interface FormattedInstructions {
  metadata: {
    vaultSignature: string;
    generatedAt: string;
    analysisDepth: number;
    contentFingerprint: string;
  };
  
  sections: {
    vaultProfile: string;
    knowledgeDiscovery: string;
    intelligentOperations: string;
    contextualGuidance: string;
    adaptiveWorkflows: string;
    vaultSpecificCommands: string;
    continuousLearning: string;
  };
  
  fullDocument: string;
}

/**
 * Dynamic Instruction Formatter Node - True dynamic content generation
 * 
 * Features:
 * - Converts semantic analysis into readable instructions
 * - Generates vault-specific guidance based on actual content
 * - Creates adaptive prompts and workflows
 * - Formats output as structured markdown
 * - Includes vault fingerprinting for uniqueness verification
 */
export class DynamicInstructionFormatterNode extends AnalysisNode {
  get name(): string { return "üìù Dynamic Instruction Formatter"; }
  get description(): string { return "Converts AI insights into structured, vault-specific instruction documents"; }

  async execute(data: AnalysisData): Promise<AnalysisData> {
    this.reportProgress(
      "Formatting dynamic instructions...",
      "Converting AI insights into comprehensive, readable instruction document",
      [
        "üìä Processing semantic analysis results",
        "üéØ Formatting vault-specific guidance", 
        "üìù Generating structured markdown output",
        "‚ú® Creating unique instruction document"
      ],
      this.getPhaseNumber()
    );

    await this.think(1000);

    try {
      // Check if dynamic instructions exist
      if (!data.dynamicInstructions?.instructions) {
        throw new Error('No dynamic instructions found. DynamicInstructionGeneratorNode must run first.');
      }

      const instructions = data.dynamicInstructions.instructions;
      const semanticAnalysis = data.dynamicInstructions.semanticAnalysis;

      this.reportProgress(
        "Processing instruction components...",
        `Formatting ${Object.keys(instructions).length} instruction components for vault ${instructions.vaultSignature}`,
        [
          `üé≠ Vault character: ${instructions.executiveSummary.vaultCharacter.substring(0, 50)}...`,
          `üîÑ ${instructions.intelligentWorkflows.knowledgeDiscovery.length} knowledge workflows`,
          `‚ö° ${instructions.vaultSpecificCommands.length} vault-specific commands`,
          `üí´ ${instructions.adaptivePrompts.length} adaptive prompts`
        ],
        this.getPhaseNumber()
      );

      await this.think(1500);

      // Generate formatted instruction document
      const formattedInstructions = this.formatInstructionDocument(instructions, semanticAnalysis);
      
      this.reportProgress(
        "Generating instruction document...",
        "Creating comprehensive markdown-formatted AI instruction guide",
        [
          `üìÑ Document sections: ${Object.keys(formattedInstructions.sections).length}`,
          `üî§ Total content: ${formattedInstructions.fullDocument.length} characters`,
          `üÜî Vault fingerprint: ${formattedInstructions.metadata.contentFingerprint}`,
          `‚ö° Analysis depth: ${formattedInstructions.metadata.analysisDepth} files`
        ],
        this.getPhaseNumber()
      );

      await this.think(1200);

      // Generate content fingerprint for uniqueness verification
      const contentFingerprint = this.generateContentFingerprint(instructions, semanticAnalysis);
      
      this.reportProgress(
        "Dynamic instruction formatting complete",
        "Generated unique, vault-specific AI instruction document",
        [
          `‚úÖ Unique vault signature: ${instructions.vaultSignature}`,
          `üìä Content fingerprint: ${contentFingerprint}`,
          `üéØ Personalized for vault characteristics`,
          `üîÑ Based on actual content analysis`
        ],
        this.getPhaseNumber(),
        true
      );

      // Store formatted instructions in analysis data
      data.formattedInstructions = formattedInstructions;

      return data;

    } catch (error) {
      console.error('Dynamic instruction formatting failed:', error);
      throw new Error(`Dynamic instruction formatting failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Format complete instruction document
   */
  private formatInstructionDocument(instructions: any, semanticAnalysis: any): FormattedInstructions {
    // Generate metadata
    const metadata = {
      vaultSignature: instructions.vaultSignature,
      generatedAt: instructions.generatedAt.toISOString(),
      analysisDepth: instructions.contentAnalysisDepth,
      contentFingerprint: this.generateContentFingerprint(instructions, semanticAnalysis)
    };

    // Generate individual sections
    const sections = {
      vaultProfile: this.formatVaultProfile(instructions, semanticAnalysis),
      knowledgeDiscovery: this.formatKnowledgeDiscovery(instructions, semanticAnalysis),
      intelligentOperations: this.formatIntelligentOperations(instructions, semanticAnalysis),
      contextualGuidance: this.formatContextualGuidance(instructions),
      adaptiveWorkflows: this.formatAdaptiveWorkflows(instructions),
      vaultSpecificCommands: this.formatVaultSpecificCommands(instructions),
      continuousLearning: this.formatContinuousLearning(instructions, semanticAnalysis)
    };

    // Combine into full document
    const fullDocument = this.assembleFullDocument(metadata, sections);

    return {
      metadata,
      sections,
      fullDocument
    };
  }

  /**
   * Format vault profile section
   */
  private formatVaultProfile(instructions: any, semanticAnalysis: any): string {
    const exec = instructions.executiveSummary;
    const topThemes = semanticAnalysis.keyThemes.slice(0, 3);
    const characteristics = semanticAnalysis.uniqueCharacteristics;

    return `# üèõÔ∏è Vault Profile

## Vault Character
${exec.vaultCharacter}

## Primary Function
${exec.primaryFunction}

## Core Knowledge Domains
${topThemes.map((theme: any, index: number) => 
  `${index + 1}. **${theme.domain}** (depth: ${Math.round(theme.depth * 100)}%)
   - Connections: ${theme.connections.slice(0, 3).join(', ')}
   - Key insights: ${theme.insights.join('; ')}`
).join('\n')}

## Unique Characteristics
${characteristics.map((char: any) => 
  `### ${char.characteristic}
**Evidence:** ${char.evidence.join('; ')}
**Implications:** ${char.implications.join('; ')}`
).join('\n\n')}

## Key Insights
${exec.keyInsights.map((insight: string) => `- ${insight}`).join('\n')}

## Recommended Approach
${exec.recommendedApproach}
`;
  }

  /**
   * Format knowledge discovery section
   */
  private formatKnowledgeDiscovery(instructions: any, semanticAnalysis: any): string {
    const networks = semanticAnalysis.knowledgeNetworks.slice(0, 4);
    const discoveryWorkflows = instructions.intelligentWorkflows.knowledgeDiscovery;

    return `# üîç Knowledge Discovery Framework

## Knowledge Networks Discovered

${networks.map((network: any) => 
  `### ${network.concept} Network (strength: ${Math.round(network.strength * 100)}%)
**Connected concepts:** ${network.relatedConcepts.slice(0, 4).join(', ')}
**Source files:** ${network.files.slice(0, 3).join(', ')}
**Linking patterns:** ${network.linkingPatterns.join('; ')}

**Discovery approach:**
- Start with ${network.concept} content
- Explore connections to ${network.relatedConcepts.slice(0, 2).join(' and ')}
- Follow linking patterns: ${network.linkingPatterns[0] || 'conceptual association'}
- Document new insights and connections`
).join('\n\n')}

## Discovery Workflows

${discoveryWorkflows.map((workflow: string, index: number) => 
  `${index + 1}. **${workflow}**
   - Apply when exploring related concepts
   - Focus on network strengthening and gap identification
   - Document insights for future reference`
).join('\n\n')}

## Knowledge Exploration Strategies

${semanticAnalysis.usagePatterns.slice(0, 3).map((pattern: any) => 
  `### ${pattern.pattern}
**Context:** ${pattern.context}
**Application:** ${pattern.examples.join('; ')}
**Frequency:** ${Math.round(pattern.frequency * 100)}% of vault operations`
).join('\n\n')}
`;
  }

  /**
   * Format intelligent operations section
   */
  private formatIntelligentOperations(instructions: any, semanticAnalysis: any): string {
    const contextualOps = instructions.contextualGuidance;
    const automations = instructions.vaultSpecificCommands.slice(0, 4);

    return `# ‚ö° Intelligent Operations

## Contextual Analysis Guidelines

### When Analyzing Content
${contextualOps.whenAnalyzing.map((guideline: string) => `- ${guideline}`).join('\n')}

### When Creating New Content
${contextualOps.whenCreating.map((guideline: string) => `- ${guideline}`).join('\n')}

### When Building Connections
${contextualOps.whenConnecting.map((guideline: string) => `- ${guideline}`).join('\n')}

### When Discovering Knowledge
${contextualOps.whenDiscovering.map((guideline: string) => `- ${guideline}`).join('\n')}

## Intelligent Automations

${automations.map((cmd: any) => 
  `### ${cmd.command}
**Purpose:** ${cmd.purpose}
**Implementation:** ${cmd.implementation}
**Usage trigger:** When working with related content or patterns`
).join('\n\n')}

## Content Pattern Recognition

${semanticAnalysis.keyThemes.slice(0, 3).map((theme: any) => 
  `### ${theme.domain} Pattern Recognition
- **Prevalence:** ${Math.round(theme.prevalence * 100)}% of analyzed content
- **Depth indicators:** ${theme.insights.slice(0, 2).join(', ')}
- **Connection points:** ${theme.connections.slice(0, 3).join(', ')}
- **Auto-trigger:** Suggest ${theme.domain} connections when themes overlap`
).join('\n\n')}
`;
  }

  /**
   * Format contextual guidance section
   */
  private formatContextualGuidance(instructions: any): string {
    const workflows = instructions.intelligentWorkflows;
    const prompts = instructions.adaptivePrompts.slice(0, 5);

    return `# üéØ Contextual Guidance System

## Workflow Applications

### Knowledge Discovery Workflows
${workflows.knowledgeDiscovery.map((workflow: string) => `- ${workflow}`).join('\n')}

### Content Creation Workflows  
${workflows.contentCreation.map((workflow: string) => `- ${workflow}`).join('\n')}

### Link Synthesis Workflows
${workflows.linkSynthesis.map((workflow: string) => `- ${workflow}`).join('\n')}

### Insight Generation Workflows
${workflows.insightGeneration.map((workflow: string) => `- ${workflow}`).join('\n')}

## Adaptive Prompting Framework

${prompts.map((prompt: any, index: number) => 
  `### Scenario ${index + 1}: ${prompt.scenario}
**Prompt:** ${prompt.prompt}
**Expected Response:** ${prompt.expectedResponse}
**Application:** Use when ${prompt.scenario.toLowerCase()} to generate contextual insights`
).join('\n\n')}

## Dynamic Response Patterns

Based on vault analysis, prioritize responses that:
1. **Connect to established knowledge networks** - Leverage existing conceptual connections
2. **Build on identified themes** - Strengthen primary domain expertise  
3. **Follow discovered patterns** - Maintain consistency with vault organization
4. **Generate actionable insights** - Focus on practical knowledge application
5. **Enhance connection discovery** - Reveal new relationships between concepts
`;
  }

  /**
   * Format adaptive workflows section
   */
  private formatAdaptiveWorkflows(instructions: any): string {
    const commands = instructions.vaultSpecificCommands;
    const summary = instructions.executiveSummary;

    return `# üîÑ Adaptive Workflows

## Vault-Specific Command Framework

${commands.map((cmd: any) => 
  `### \`${cmd.command}\`
**Purpose:** ${cmd.purpose}
**Implementation:**
\`\`\`
${cmd.implementation}
\`\`\`
**When to use:** ${this.generateUsageContext(cmd.command, summary)}
**Expected outcome:** Enhanced understanding of ${this.extractDomainFromCommand(cmd.command)} relationships`
).join('\n\n')}

## Workflow Orchestration

### Primary Workflow: ${summary.primaryFunction}
1. **Identify** relevant content using vault-specific patterns
2. **Analyze** using established knowledge networks
3. **Connect** to related concepts and domains
4. **Synthesize** insights based on vault characteristics
5. **Document** discoveries for future reference

### Secondary Workflows
Based on vault analysis, implement these adaptive workflows:

#### Content Discovery Workflow
- Trigger: When exploring new or existing content
- Actions: Apply knowledge network analysis, identify connection opportunities
- Output: Enhanced content understanding and relationship mapping

#### Knowledge Synthesis Workflow  
- Trigger: When working with multiple related concepts
- Actions: Cross-reference knowledge networks, identify synthesis opportunities
- Output: Novel insights and strengthened conceptual connections

#### Pattern Recognition Workflow
- Trigger: When analyzing content patterns or organization
- Actions: Compare against established vault patterns, identify deviations or enhancements
- Output: Improved pattern recognition and organization recommendations
`;
  }

  /**
   * Format vault-specific commands section
   */
  private formatVaultSpecificCommands(instructions: any): string {
    const commands = instructions.vaultSpecificCommands;
    const signature = instructions.vaultSignature;

    return `# üõ†Ô∏è Vault-Specific Command Interface

## Command Registry
*Generated for vault: \`${signature}\`*

${commands.map((cmd: any, index: number) => 
  `### Command ${index + 1}: \`${cmd.command}\`

**Primary Purpose:** ${cmd.purpose}

**Implementation Details:**
\`\`\`bash
# ${cmd.command}
${cmd.implementation}
\`\`\`

**Usage Pattern:**
- Invoke when: ${this.generateInvocationContext(cmd)}
- Expected result: ${this.generateExpectedResult(cmd)}
- Follow-up actions: ${this.generateFollowUpActions(cmd)}

**Integration Points:**
- Links with: ${this.identifyIntegrationPoints(cmd, commands)}
- Enhances: ${this.identifyEnhancements(cmd)}
`
).join('\n---\n\n')}

## Command Orchestration Patterns

### Sequential Execution
For comprehensive analysis, execute commands in this order:
${commands.slice(0, 3).map((cmd: any, index: number) => 
  `${index + 1}. \`${cmd.command}\` - ${cmd.purpose.split('.')[0]}`
).join('\n')}

### Parallel Execution
For efficiency, these commands can be run simultaneously:
${commands.slice(0, 2).map((cmd: any) => 
  `- \`${cmd.command}\` (independent operation)`
).join('\n')}

### Conditional Execution
Trigger specific commands based on content analysis results:
${commands.map((cmd: any) => 
  `- If ${this.extractCondition(cmd)}: Execute \`${cmd.command}\``
).join('\n')}
`;
  }

  /**
   * Format continuous learning section
   */
  private formatContinuousLearning(instructions: any, semanticAnalysis: any): string {
    const characteristics = semanticAnalysis.uniqueCharacteristics;
    const networks = semanticAnalysis.knowledgeNetworks.slice(0, 3);

    return `# üå± Continuous Learning & Adaptation

## Learning Objectives
Based on vault analysis, focus continuous learning on:

${characteristics.map((char: any) => 
  `### ${char.characteristic}
**Current understanding:** ${char.evidence.slice(0, 2).join('; ')}
**Learning opportunities:** ${char.implications.join('; ')}
**Adaptation strategy:** Enhance vault capabilities in this area through targeted content development`
).join('\n\n')}

## Knowledge Network Evolution

${networks.map((network: any) => 
  `### ${network.concept} Network Growth
**Current strength:** ${Math.round(network.strength * 100)}%
**Growth potential:** Expand connections to ${network.relatedConcepts.slice(-2).join(' and ')}
**Learning focus:** Deepen understanding of ${network.linkingPatterns[0] || 'conceptual relationships'}
**Target outcome:** Strengthen network resilience and discovery potential`
).join('\n\n')}

## Adaptation Triggers

### Content Evolution Indicators
- New file creation in established domains
- Emergence of novel concept connections
- Changes in knowledge network density
- Evolution of organizational patterns

### Response Protocols
1. **Monitor:** Track changes in vault content and structure
2. **Analyze:** Assess impact on existing knowledge networks
3. **Adapt:** Modify instructions and workflows accordingly  
4. **Validate:** Verify improvements in knowledge discovery and connection quality
5. **Document:** Record adaptations for future reference

## Feedback Integration

### Performance Metrics
- Knowledge discovery effectiveness
- Connection quality and relevance
- Workflow efficiency improvements
- User satisfaction with AI assistance

### Continuous Improvement Process
1. **Collect feedback** on AI instruction effectiveness
2. **Analyze patterns** in successful and unsuccessful operations
3. **Identify gaps** in current instruction coverage
4. **Generate updates** to instruction sets based on learning
5. **Test adaptations** against vault content and user needs

---

## Regeneration Guidelines

To maintain instruction relevance and accuracy:

### Trigger Regeneration When:
- Vault content grows by >20%
- New primary domains emerge
- Knowledge network patterns shift significantly
- User feedback indicates instruction obsolescence

### Regeneration Process:
1. Re-run complete semantic analysis
2. Compare against previous instruction set
3. Identify significant changes and adaptations needed
4. Generate updated instruction document
5. Validate improvements and effectiveness

*Last generated: ${instructions.generatedAt.toISOString()}*
*Vault signature: \`${instructions.vaultSignature}\`*
*Content fingerprint: \`${this.generateContentFingerprint(instructions, semanticAnalysis)}\`*
`;
  }

  /**
   * Assemble full document from sections
   */
  private assembleFullDocument(metadata: any, sections: any): string {
    const timestamp = new Date(metadata.generatedAt).toLocaleString();
    
    return `---
vault_signature: "${metadata.vaultSignature}"
generated_at: "${metadata.generatedAt}"
analysis_depth: ${metadata.analysisDepth}
content_fingerprint: "${metadata.contentFingerprint}"
instruction_type: "dynamic_ai_generated"
uniqueness_verified: true
---

# OBSIUS AI Instructions
*Dynamic vault-specific guidance generated ${timestamp}*

> **üéØ Uniqueness Guarantee:** This instruction set is uniquely generated for your vault based on actual content analysis. No two vaults will receive identical instructions.

**Vault Signature:** \`${metadata.vaultSignature}\`  
**Analysis Depth:** ${metadata.analysisDepth} files deeply analyzed  
**Content Fingerprint:** \`${metadata.contentFingerprint}\`

${sections.vaultProfile}

${sections.knowledgeDiscovery}

${sections.intelligentOperations}

${sections.contextualGuidance}

${sections.adaptiveWorkflows}

${sections.vaultSpecificCommands}

${sections.continuousLearning}

---

*Generated by OBSIUS Dynamic Instruction Generator - Each vault receives personalized AI guidance based on unique content analysis.*
`;
  }

  /**
   * Generate content fingerprint for uniqueness verification
   */
  private generateContentFingerprint(instructions: any, semanticAnalysis: any): string {
    const themes = semanticAnalysis.keyThemes.map((t: any) => t.domain).sort().join('|');
    const networks = semanticAnalysis.knowledgeNetworks.length;
    const characteristics = semanticAnalysis.uniqueCharacteristics.length;
    const commands = instructions.vaultSpecificCommands.length;
    const timestamp = Date.now().toString(36);
    
    // Create a unique hash-like string
    const fingerprint = Buffer.from(`${themes}-${networks}n-${characteristics}c-${commands}cmd-${timestamp}`)
      .toString('base64')
      .substring(0, 16)
      .replace(/[+/=]/g, '');
    
    return fingerprint.toUpperCase();
  }

  /**
   * Helper methods for formatting specific elements
   */
  
  private generateUsageContext(command: string, summary: any): string {
    if (command.includes('explore')) {
      return 'Deepening understanding of specific domain content';
    } else if (command.includes('map')) {
      return 'Visualizing and analyzing knowledge connections';
    } else {
      return 'Enhancing vault operations and knowledge discovery';
    }
  }

  private extractDomainFromCommand(command: string): string {
    const parts = command.split('-');
    return parts.find(part => !['explore', 'map', 'network', 'analyze'].includes(part)) || 'knowledge';
  }

  private generateInvocationContext(cmd: any): string {
    return `Working with ${this.extractDomainFromCommand(cmd.command)} content or seeking deeper insights`;
  }

  private generateExpectedResult(cmd: any): string {
    return `Enhanced understanding and connection discovery in ${this.extractDomainFromCommand(cmd.command)} domain`;
  }

  private generateFollowUpActions(cmd: any): string {
    return 'Document insights, update connections, explore related concepts';
  }

  private identifyIntegrationPoints(cmd: any, allCommands: any[]): string {
    const otherCommands = allCommands.filter(c => c.command !== cmd.command);
    return otherCommands.slice(0, 2).map(c => c.command).join(', ') || 'Other vault commands';
  }

  private identifyEnhancements(cmd: any): string {
    return 'Knowledge discovery, content organization, connection quality';
  }

  private extractCondition(cmd: any): string {
    const domain = this.extractDomainFromCommand(cmd.command);
    return `${domain} content requires analysis`;
  }

  private getPhaseNumber(): number {
    return 9; // Position in workflow
  }
}