/**
 * Final Instruction Synthesis Node - Vault Knowledge Structure Mapping
 * 
 * This node creates a concise knowledge map that focuses on vault-specific
 * characteristics and content structure, NOT on tool usage instructions.
 * 
 * Key features:
 * - Extracts vault-specific knowledge structure and patterns
 * - Generates concise vault knowledge map (30-50 lines)
 * - Focuses on WHAT the vault contains, not HOW to use Obsius
 * - Identifies actual usage patterns and content relationships
 */

import { App } from 'obsidian';
import { ToolRegistry } from '../../tools/ToolRegistry';
import { AnalysisNode, AnalysisData, AnalysisProgress } from './VaultAnalysisWorkflow';
import { getEffectiveChatLanguage } from '../../utils/i18n';

/**
 * Vault knowledge structure components
 */
export interface VaultKnowledgeMap {
  vaultProfile: string;
  knowledgeDomains: { name: string; description: string; folderPath: string; }[];
  folderStructure: { name: string; purpose: string; contentType: string; }[];
  usagePatterns: { pattern: string; evidence: string[]; }[];
  contentRelationships: { domain1: string; domain2: string; relationship: string; }[];
  knowledgeClusters: { 
    clusterName: string; 
    clusterType: 'topic' | 'importance' | 'contentType' | 'usage';
    members: string[]; 
    centralConcept: string;
    strength: number;
  }[];
  languageUsed: string;
  generatedAt: string;
}

/**
 * Final Instruction Synthesis Node - Creates concise, localized OBSIUS.md
 */
export class FinalInstructionSynthesisNode extends AnalysisNode {
  get name(): string { return "üó∫Ô∏è Vault Knowledge Mapping"; }
  get description(): string { return "Creating concise vault knowledge map focused on content structure and patterns"; }

  async execute(data: AnalysisData): Promise<AnalysisData> {
    this.reportProgress(
      "Mapping vault knowledge structure...",
      "Analyzing vault content patterns and knowledge organization",
      [
        "üèóÔ∏è Identifying actual folder purposes and content types",
        "üß† Discovering knowledge domains from real content", 
        "üîç Detecting usage patterns and content relationships",
        "üó∫Ô∏è Creating focused vault knowledge map"
      ],
      this.getPhaseNumber()
    );

    await this.think(800);

    try {
      // Get user's effective language
      const effectiveLanguage = getEffectiveChatLanguage();
      
      // Analyze vault knowledge structure from actual content
      const knowledgeMap = this.analyzeVaultKnowledgeStructure(data);
      
      this.reportProgress(
        "Analyzing vault content structure...",
        `Discovered ${knowledgeMap.knowledgeDomains.length} knowledge domains and ${knowledgeMap.folderStructure.length} content areas`,
        [
          `üéØ Language: ${effectiveLanguage === 'ja' ? 'Êó•Êú¨Ë™û' : 'English'}`,
          `üìÅ Content areas: ${knowledgeMap.folderStructure.slice(0, 3).map(f => f.name).join(', ')}`,
          `üß† Knowledge domains: ${knowledgeMap.knowledgeDomains.slice(0, 3).map(d => d.name).join(', ')}`,
          `üìã Usage patterns: ${knowledgeMap.usagePatterns.length} identified`
        ],
        this.getPhaseNumber()
      );

      await this.think(1000);

      // Generate vault knowledge map document
      const knowledgeDocument = await this.generateKnowledgeMapDocument(knowledgeMap, effectiveLanguage);
      
      this.reportProgress(
        "Vault knowledge mapping complete",
        "Generated concise vault knowledge map focused on content structure",
        [
          `‚úÖ Language: ${effectiveLanguage === 'ja' ? 'Êó•Êú¨Ë™û' : 'English'}`,
          `üìÑ Document length: ${knowledgeDocument.length} characters (focused)`,
          `üó∫Ô∏è Knowledge structure focus - no tool instructions`,
          `üìä Content-driven insights and relationships`
        ],
        this.getPhaseNumber(),
        true
      );

      // Store the knowledge map document
      data.finalInstructions = {
        document: knowledgeDocument,
        language: effectiveLanguage,
        generatedAt: new Date().toISOString(),
        characterCount: knowledgeDocument.length
      };

      return data;

    } catch (error) {
      console.error('Vault knowledge mapping failed:', error);
      throw new Error(`Vault knowledge mapping failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Analyze vault knowledge structure from actual content and patterns
   * Enhanced to leverage sophisticated analysis from EnhancedDeepContentDiscoveryNode
   */
  private analyzeVaultKnowledgeStructure(data: AnalysisData): VaultKnowledgeMap {
    const knowledgeDomains: { name: string; description: string; folderPath: string; }[] = [];
    const folderStructure: { name: string; purpose: string; contentType: string; }[] = [];
    const usagePatterns: { pattern: string; evidence: string[]; }[] = [];
    const contentRelationships: { domain1: string; domain2: string; relationship: string; }[] = [];

    // Prioritize enhanced content analysis if available
    if (data.enhancedContent) {
      return this.analyzeFromEnhancedContent(data);
    }
    
    // Fallback to deep content analysis
    if (data.deepContent?.folderSummaries) {
      for (const folder of data.deepContent.folderSummaries) {
        const actualPurpose = this.analyzeFolderContentPurpose(folder);
        const contentType = this.determineContentType(folder);
        
        folderStructure.push({
          name: folder.folderPath || 'Unknown',
          purpose: actualPurpose,
          contentType: contentType
        });

        // Extract knowledge domains from actual content
        if (this.isKnowledgeDomain(folder)) {
          knowledgeDomains.push({
            name: this.extractDomainName(folder),
            description: this.generateDomainDescription(folder),
            folderPath: folder.folderPath || ''
          });
        }
      }
    }

    // Detect usage patterns from content patterns
    usagePatterns.push(...this.detectActualUsagePatterns(data));

    // Identify content relationships
    contentRelationships.push(...this.analyzeContentRelationships(data));

    // Generate basic knowledge clusters for fallback analysis
    const knowledgeClusters = this.generateBasicKnowledgeClusters(data, getEffectiveChatLanguage());

    return {
      vaultProfile: this.generateVaultProfile(data),
      knowledgeDomains,
      folderStructure,
      usagePatterns,
      contentRelationships,
      knowledgeClusters,
      languageUsed: getEffectiveChatLanguage(),
      generatedAt: new Date().toISOString()
    };
  }

  /**
   * Generate a comprehensive vault profile from analysis data
   */
  private generateVaultProfile(data: AnalysisData): string {
    const totalFiles = data.vaultStructure?.totalFiles || 0;
    const totalFolders = data.vaultStructure?.totalFolders || 0;
    const primaryDomains = data.insights?.primaryDomains?.length || 0;
    const language = getEffectiveChatLanguage();

    if (language === 'ja') {
      return `${totalFiles}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„ÄÅ${totalFolders}ÂÄã„ÅÆ„Éï„Ç©„É´„ÉÄ„ÇíÊåÅ„Å§${primaryDomains}ÂàÜÈáé„ÅÆÁü•Ë≠òÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†`;
    } else {
      return `Knowledge management system with ${totalFiles} files across ${totalFolders} folders, covering ${primaryDomains} primary domains`;
    }
  }

  /**
   * Analyze folder content purpose from its actual characteristics
   */
  private analyzeFolderContentPurpose(folder: any): string {
    const name = (folder.folderPath || '').toLowerCase();
    const language = getEffectiveChatLanguage();
    
    if (language === 'ja') {
      if (name.includes('journal') || name.includes('Êó•Ë®ò')) return 'Êó•Ë®ò„Éª„É©„Ç§„Éï„É≠„Ç∞';
      if (name.includes('permanent')) return 'ÊÅí‰πÖÁöÑÁü•Ë≠ò„ÉªÂèÇËÄÉË≥áÊñô';
      if (name.includes('index')) return '‰ΩìÁ≥ªÁöÑÂàÜÈ°û„ÉªÁ¥¢Âºï';
      if (name.includes('temp') || name.includes('templates')) return '„ÉÜ„É≥„Éó„É¨„Éº„Éà„Éª‰∏ÄÊôÇ‰øùÂ≠ò';
      if (name.includes('audio')) return '„Ç™„Éº„Éá„Ç£„Ç™Ê©üÂô®„ÉªÈü≥Èüø';
      if (name.includes('fragrance')) return 'È¶ôÊ∞¥„Éª„Éï„É¨„Ç∞„É©„É≥„Çπ';
      if (name.includes('technology') || name.includes('tech')) return 'ÊäÄË°ì„ÉªÈñãÁô∫';
      if (name.includes('apps')) return '„Ç¢„Éó„É™Ë®≠ÂÆö„Éª„ÉÑ„Éº„É´';
      return '„Åù„ÅÆ‰ªñ„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
    } else {
      if (name.includes('journal') || name.includes('diary')) return 'Journal & Life Logging';
      if (name.includes('permanent') || name.includes('evergreen')) return 'Permanent Knowledge & Reference';
      if (name.includes('index') || name.includes('hub')) return 'Systematic Classification & Index';
      if (name.includes('temp') || name.includes('templates')) return 'Templates & Temporary Storage';
      if (name.includes('audio')) return 'Audio Equipment & Sound';
      if (name.includes('fragrance')) return 'Fragrance & Perfume';
      if (name.includes('technology') || name.includes('tech')) return 'Technology & Development';
      if (name.includes('apps')) return 'App Settings & Tools';
      return 'Other Content';
    }
  }

  /**
   * Determine content type from folder characteristics
   */
  private determineContentType(folder: any): string {
    const name = (folder.folderPath || '').toLowerCase();
    const fileCount = folder.fileCount || 0;
    const language = getEffectiveChatLanguage();
    
    if (language === 'ja') {
      if (name.includes('image') || name.includes('photo')) return 'ÁîªÂÉè„ÉªÂÜôÁúü';
      if (name.includes('document') || name.includes('docs')) return 'ÊñáÊõ∏„Éª„Éâ„Ç≠„É•„É°„É≥„Éà';
      if (name.includes('note') || name.includes('memo')) return '„Éé„Éº„Éà„Éª„É°„É¢';
      if (name.includes('config') || name.includes('setting')) return 'Ë®≠ÂÆö„ÉªÊßãÊàê';
      if (fileCount > 50) return 'Â§ßÈáè„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
      if (fileCount > 10) return '‰∏≠Á®ãÂ∫¶„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
      return 'Â∞ëÈáè„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
    } else {
      if (name.includes('image') || name.includes('photo')) return 'Images & Photos';
      if (name.includes('document') || name.includes('docs')) return 'Documents & Files';
      if (name.includes('note') || name.includes('memo')) return 'Notes & Memos';
      if (name.includes('config') || name.includes('setting')) return 'Configuration & Settings';
      if (fileCount > 50) return 'High-volume Content';
      if (fileCount > 10) return 'Medium-volume Content';
      return 'Low-volume Content';
    }
  }

  /**
   * Detect actual usage patterns from vault content
   */
  private detectActualUsagePatterns(data: AnalysisData): { pattern: string; evidence: string[]; }[] {
    const patterns: { pattern: string; evidence: string[]; }[] = [];
    const language = getEffectiveChatLanguage();
    
    // Analyze frontmatter usage patterns
    if (data.contentPatterns?.frontmatterFields) {
      const fieldCount = data.contentPatterns.frontmatterFields.size;
      if (fieldCount > 0) {
        const evidence = Array.from(data.contentPatterns.frontmatterFields.keys()).slice(0, 3);
        if (language === 'ja') {
          patterns.push({
            pattern: '„Éï„É≠„É≥„Éà„Éû„Çø„Éº„Çí‰Ωø„Å£„ÅüÊßãÈÄ†Âåñ„É°„Çø„Éá„Éº„Çø',
            evidence: evidence
          });
        } else {
          patterns.push({
            pattern: 'Structured metadata using frontmatter',
            evidence: evidence
          });
        }
      }
    }
    
    // Analyze tagging patterns
    if (data.contentPatterns?.tagCategories) {
      const tagCount = data.contentPatterns.tagCategories.size;
      if (tagCount > 0) {
        const evidence = Array.from(data.contentPatterns.tagCategories.keys()).slice(0, 3);
        if (language === 'ja') {
          patterns.push({
            pattern: '„Ç´„ÉÜ„Ç¥„É™„ÉºÂà•„Çø„Ç∞ÂàÜÈ°û„Ç∑„Çπ„ÉÜ„É†',
            evidence: evidence
          });
        } else {
          patterns.push({
            pattern: 'Categorical tagging classification system',
            evidence: evidence
          });
        }
      }
    }
    
    // Analyze naming conventions
    if (data.contentPatterns?.namingConventions) {
      const conventions = data.contentPatterns.namingConventions;
      if (conventions.length > 0) {
        if (language === 'ja') {
          patterns.push({
            pattern: '‰∏ÄË≤´„Åó„ÅüÂëΩÂêçË¶èÂâá„ÅÆ‰ΩøÁî®',
            evidence: conventions.slice(0, 3)
          });
        } else {
          patterns.push({
            pattern: 'Consistent naming convention usage',
            evidence: conventions.slice(0, 3)
          });
        }
      }
    }
    
    return patterns;
  }

  /**
   * Analyze content relationships between knowledge domains
   */
  private analyzeContentRelationships(data: AnalysisData): { domain1: string; domain2: string; relationship: string; }[] {
    const relationships: { domain1: string; domain2: string; relationship: string; }[] = [];
    const language = getEffectiveChatLanguage();
    
    // Analyze relationships between primary domains
    const domains = data.insights?.primaryDomains || [];
    
    for (let i = 0; i < domains.length; i++) {
      for (let j = i + 1; j < domains.length; j++) {
        const domain1 = domains[i];
        const domain2 = domains[j];
        
        // Determine relationship type based on domain characteristics
        let relationshipType = '';
        if (language === 'ja') {
          if (domain1.includes('ÊäÄË°ì') && domain2.includes('ÈñãÁô∫')) {
            relationshipType = 'ÊäÄË°ìÁöÑÈñ¢ÈÄ£ÊÄß';
          } else if (domain1.includes('Êó•Ë®ò') && domain2.includes('ÂÄã‰∫∫')) {
            relationshipType = 'ÂÄã‰∫∫ÁöÑÈñ¢ÈÄ£ÊÄß';
          } else {
            relationshipType = 'Áü•Ë≠òÈ†òÂüü„ÅÆÈñ¢ÈÄ£ÊÄß';
          }
        } else {
          if (domain1.includes('tech') && domain2.includes('development')) {
            relationshipType = 'Technical relationship';
          } else if (domain1.includes('journal') && domain2.includes('personal')) {
            relationshipType = 'Personal relationship';
          } else {
            relationshipType = 'Knowledge domain relationship';
          }
        }
        
        relationships.push({
          domain1,
          domain2,
          relationship: relationshipType
        });
      }
    }
    
    return relationships.slice(0, 5); // Limit to top 5 relationships
  }

  /**
   * Analyze vault structure using enhanced content analysis
   * This provides much more sophisticated and accurate vault understanding
   */
  private analyzeFromEnhancedContent(data: AnalysisData): VaultKnowledgeMap {
    const enhanced = data.enhancedContent!;
    const language = getEffectiveChatLanguage();
    
    // Extract knowledge domains from enhanced analysis
    const knowledgeDomains = enhanced.knowledgePatterns.primaryDomains.map((domain: string, index: number) => {
      const representativeFile = enhanced.representativeFiles[index];
      return {
        name: domain,
        description: this.generateEnhancedDomainDescription(domain, representativeFile, language),
        folderPath: representativeFile?.path.split('/').slice(0, -1).join('/') || domain
      };
    });
    
    // Extract folder structure from representative files and content distribution
    const folderStructure = this.extractFolderStructureFromEnhanced(enhanced, language);
    
    // Extract sophisticated usage patterns
    const usagePatterns = this.extractEnhancedUsagePatterns(enhanced, language);
    
    // Extract content relationships from knowledge connections
    const contentRelationships = this.extractEnhancedContentRelationships(enhanced, language);
    
    // Generate knowledge clusters for deeper understanding
    const knowledgeClusters = this.generateKnowledgeClusters(enhanced, language);
    
    return {
      vaultProfile: this.generateEnhancedVaultProfile(data, language),
      knowledgeDomains,
      folderStructure,
      usagePatterns,
      contentRelationships,
      knowledgeClusters,
      languageUsed: language,
      generatedAt: new Date().toISOString()
    };
  }
  
  /**
   * Generate enhanced domain description from sophisticated analysis
   */
  private generateEnhancedDomainDescription(domain: string, representativeFile: any, language: string): string {
    if (!representativeFile) {
      return language === 'ja' ? `${domain}„Å´Èñ¢„Åô„ÇãÁü•Ë≠òÈ†òÂüü` : `Knowledge domain related to ${domain}`;
    }
    
    const keyTopics = representativeFile.keyTopics?.slice(0, 3) || [];
    const importance = Math.round(representativeFile.importance || 0);
    
    if (language === 'ja') {
      const topicsText = keyTopics.length > 0 ? `Ôºà${keyTopics.join('„ÄÅ')}Ôºâ` : '';
      return `ÈáçË¶ÅÂ∫¶${importance}/10„ÅÆÁü•Ë≠òÈ†òÂüü${topicsText}`;
    } else {
      const topicsText = keyTopics.length > 0 ? ` (${keyTopics.join(', ')})` : '';
      return `Knowledge domain with importance ${importance}/10${topicsText}`;
    }
  }
  
  /**
   * Extract folder structure from enhanced content analysis
   */
  private extractFolderStructureFromEnhanced(enhanced: any, language: string): { name: string; purpose: string; contentType: string; }[] {
    const folderMap = new Map<string, { files: any[]; types: string[]; }>();
    
    // Group representative files by folder
    for (const file of enhanced.representativeFiles) {
      const folderPath = file.path.split('/').slice(0, -1).join('/') || '.';
      if (!folderMap.has(folderPath)) {
        folderMap.set(folderPath, { files: [], types: [] });
      }
      folderMap.get(folderPath)!.files.push(file);
      if (file.category && !folderMap.get(folderPath)!.types.includes(file.category)) {
        folderMap.get(folderPath)!.types.push(file.category);
      }
    }
    
    const folderStructure: { name: string; purpose: string; contentType: string; }[] = [];
    
    for (const [folderPath, info] of folderMap.entries()) {
      const folderName = folderPath.split('/').pop() || folderPath;
      const avgImportance = info.files.reduce((sum, f) => sum + (f.importance || 0), 0) / info.files.length;
      
      folderStructure.push({
        name: folderName,
        purpose: this.generateFolderPurposeFromFiles(info.files, language),
        contentType: this.generateContentTypeFromFiles(info.files, avgImportance, language)
      });
    }
    
    return folderStructure;
  }
  
  /**
   * Generate folder purpose from actual file analysis
   */
  private generateFolderPurposeFromFiles(files: any[], language: string): string {
    const categories = files.map(f => f.category).filter(Boolean);
    const avgImportance = files.reduce((sum, f) => sum + (f.importance || 0), 0) / files.length;
    
    if (language === 'ja') {
      if (avgImportance > 8) return '‰∏≠Ê†∏ÁöÑ„Å™Áü•Ë≠òÁÆ°ÁêÜ';
      if (avgImportance > 5) return 'ÈáçË¶Å„Å™ÂèÇËÄÉË≥áÊñô';
      if (categories.includes('hub')) return '„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„Éª„Éè„Éñ';
      if (categories.includes('technical')) return 'ÊäÄË°ìÊñáÊõ∏„Éª‰ªïÊßò';
      return '‰∏ÄËà¨ÁöÑ„Å™„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
    } else {
      if (avgImportance > 8) return 'Core knowledge management';
      if (avgImportance > 5) return 'Important reference material';
      if (categories.includes('hub')) return 'Navigation hub';
      if (categories.includes('technical')) return 'Technical documentation';
      return 'General content';
    }
  }
  
  /**
   * Generate content type from file analysis
   */
  private generateContentTypeFromFiles(files: any[], avgImportance: number, language: string): string {
    const topicCount = files.reduce((sum, f) => sum + (f.keyTopics?.length || 0), 0);
    
    if (language === 'ja') {
      if (topicCount > 15) return 'Â§öÊßò„Å™Â∞ÇÈñÄÁü•Ë≠ò';
      if (avgImportance > 7) return 'È´òÂìÅË≥™„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
      if (files.length > 3) return 'Ë±äÂØå„Å™„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
      return 'Ê®ôÊ∫ñÁöÑ„Å™„Ç≥„É≥„ÉÜ„É≥„ÉÑ';
    } else {
      if (topicCount > 15) return 'Diverse specialized knowledge';
      if (avgImportance > 7) return 'High-quality content';
      if (files.length > 3) return 'Rich content collection';
      return 'Standard content';
    }
  }
  
  /**
   * Extract sophisticated usage patterns from enhanced analysis
   */
  private extractEnhancedUsagePatterns(enhanced: any, language: string): { pattern: string; evidence: string[]; }[] {
    const patterns: { pattern: string; evidence: string[]; }[] = [];
    
    // Organization sophistication pattern
    const orgLevel = enhanced.vaultCharacteristics.organizationLevel;
    if (orgLevel === 'sophisticated') {
      patterns.push({
        pattern: language === 'ja' ? 'È´òÂ∫¶„Å™Áü•Ë≠òÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†' : 'Sophisticated knowledge management system',
        evidence: enhanced.knowledgePatterns.organizationPrinciples.slice(0, 3)
      });
    }
    
    // Technical complexity pattern
    const complexity = enhanced.vaultCharacteristics.overallComplexity;
    if (complexity === 'complex') {
      patterns.push({
        pattern: language === 'ja' ? 'Ë§áÈõë„Å™ÊäÄË°ìÊñáÊõ∏ÁÆ°ÁêÜ' : 'Complex technical documentation management',
        evidence: enhanced.knowledgePatterns.technicalPatterns.slice(0, 3)
      });
    }
    
    // Knowledge connectivity pattern
    const connections = enhanced.knowledgePatterns.knowledgeConnections;
    if (connections.length > 10) {
      patterns.push({
        pattern: language === 'ja' ? 'Ë±äÂØå„Å™Áü•Ë≠òÈñìÈÄ£Êê∫' : 'Rich knowledge interconnection',
        evidence: connections.slice(0, 4)
      });
    }
    
    // Content focus pattern
    const contentFocus = enhanced.vaultCharacteristics.contentFocus;
    if (contentFocus.length > 0) {
      patterns.push({
        pattern: language === 'ja' ? 'Â∞ÇÈñÄÂàÜÈáé„Å∏„ÅÆÈõÜ‰∏≠' : 'Specialized domain focus',
        evidence: contentFocus.slice(0, 3)
      });
    }
    
    return patterns;
  }
  
  /**
   * Extract enhanced content relationships
   */
  private extractEnhancedContentRelationships(enhanced: any, language: string): { domain1: string; domain2: string; relationship: string; }[] {
    const relationships: { domain1: string; domain2: string; relationship: string; }[] = [];
    const domains = enhanced.knowledgePatterns.primaryDomains;
    
    // Create relationships between domains based on knowledge connections
    for (let i = 0; i < domains.length && i < 3; i++) {
      for (let j = i + 1; j < domains.length && j < 4; j++) {
        const domain1 = domains[i];
        const domain2 = domains[j];
        
        // Find connecting patterns between domains
        const connectionType = this.inferConnectionType(domain1, domain2, enhanced, language);
        
        relationships.push({
          domain1,
          domain2,
          relationship: connectionType
        });
      }
    }
    
    return relationships.slice(0, 5);
  }
  
  /**
   * Infer connection type between domains
   */
  private inferConnectionType(domain1: string, domain2: string, enhanced: any, language: string): string {
    const connections = enhanced.knowledgePatterns.knowledgeConnections;
    const sharedConnections = connections.filter((conn: string) => 
      conn.toLowerCase().includes(domain1.toLowerCase()) && 
      conn.toLowerCase().includes(domain2.toLowerCase())
    );
    
    if (language === 'ja') {
      if (sharedConnections.length > 0) return 'ÂÖ±ÈÄöÊ¶ÇÂøµ„Å´„Çà„ÇãÈñ¢ÈÄ£';
      if (domain1.includes('ÊäÄË°ì') || domain2.includes('ÊäÄË°ì')) return 'ÊäÄË°ìÁöÑÈñ¢ÈÄ£ÊÄß';
      return 'Áü•Ë≠òÈ†òÂüü„ÅÆÁõ∏‰∫íË£úÂÆå';
    } else {
      if (sharedConnections.length > 0) return 'Shared conceptual relationship';
      if (domain1.includes('tech') || domain2.includes('tech')) return 'Technical relationship';
      return 'Complementary knowledge domains';
    }
  }
  
  /**
   * Generate enhanced vault profile
   */
  private generateEnhancedVaultProfile(data: AnalysisData, language: string): string {
    const enhanced = data.enhancedContent!;
    const staging = enhanced.stagingResults;
    const characteristics = enhanced.vaultCharacteristics;
    
    if (language === 'ja') {
      return `${staging.totalFilesAnalyzed}„Éï„Ç°„Ç§„É´ÔºàË©≥Á¥∞ÂàÜÊûê${staging.deepFilesRead}„Éï„Ç°„Ç§„É´Ôºâ„ÅÆ${characteristics.overallComplexity}„É¨„Éô„É´Áü•Ë≠òÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÄÇ${characteristics.organizationLevel}„Å™ÁµÑÁπîÂåñ„Å®${characteristics.knowledgeDepth}„Å™Áü•Ë≠òÊßãÈÄ†„ÇíÊåÅ„Å§„ÄÇ`;
    } else {
      return `${characteristics.overallComplexity.charAt(0).toUpperCase() + characteristics.overallComplexity.slice(1)}-level knowledge management system with ${staging.totalFilesAnalyzed} files (${staging.deepFilesRead} deeply analyzed). Features ${characteristics.organizationLevel} organization and ${characteristics.knowledgeDepth} knowledge structure.`;
    }
  }
  
  /**
   * Check if folder represents a knowledge domain
   */
  private isKnowledgeDomain(folder: any): boolean {
    const name = (folder.folderPath || '').toLowerCase();
    const fileCount = folder.fileCount || 0;
    
    // Consider it a knowledge domain if it has substantial content
    return fileCount > 3 && !name.includes('temp') && !name.includes('trash') && !name.includes('archive');
  }
  
  /**
   * Extract domain name from folder
   */
  private extractDomainName(folder: any): string {
    const path = folder.folderPath || 'Unknown';
    return path.split('/').pop() || path;
  }
  
  /**
   * Generate domain description from folder characteristics
   */
  private generateDomainDescription(folder: any): string {
    const name = (folder.folderPath || '').toLowerCase();
    const fileCount = folder.fileCount || 0;
    const language = getEffectiveChatLanguage();
    
    if (language === 'ja') {
      return `${fileCount}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂê´„ÇÄ${this.analyzeFolderContentPurpose(folder)}`;
    } else {
      return `${this.analyzeFolderContentPurpose(folder)} containing ${fileCount} files`;
    }
  }
  
  /**
   * Generate vault knowledge map document
   */
  private async generateKnowledgeMapDocument(knowledgeMap: VaultKnowledgeMap, language: string): Promise<string> {
    const isJapanese = language === 'ja';
    const timestamp = new Date().toLocaleString(isJapanese ? 'ja-JP' : 'en-US');
    
    if (isJapanese) {
      return this.generateJapaneseKnowledgeMap(knowledgeMap, timestamp);
    } else {
      return this.generateEnglishKnowledgeMap(knowledgeMap, timestamp);
    }
  }
  
  /**
   * Generate Japanese vault knowledge map
   */
  private generateJapaneseKnowledgeMap(knowledgeMap: VaultKnowledgeMap, timestamp: string): string {
    return `---
created: ${knowledgeMap.generatedAt}
tags:
  - obsius
  - vault-knowledge
  - knowledge-structure
language: ja
---

# „É¥„Ç©„É´„ÉàÁü•Ë≠òÊßãÈÄ†„Éû„ÉÉ„Éó

*${timestamp} Ëá™ÂãïÁîüÊàê*

## „É¥„Ç©„É´„ÉàÊ¶ÇË¶Å

${knowledgeMap.vaultProfile}

## „Éï„Ç©„É´„ÉÄÊßãÈÄ†„Å®Áî®ÈÄî

${knowledgeMap.folderStructure.map(folder => 
  `- **${folder.name}**: ${folder.purpose} (${folder.contentType})`
).join('\n')}

## Áü•Ë≠òÈ†òÂüü

${knowledgeMap.knowledgeDomains.map(domain => 
  `- **${domain.name}**: ${domain.description}\n  - „Éë„Çπ: \`${domain.folderPath}\``
).join('\n')}

## ÈÅãÁî®„Éë„Çø„Éº„É≥

${knowledgeMap.usagePatterns.map(pattern => 
  `- **${pattern.pattern}**\n  - Ê†πÊã†: ${pattern.evidence.join(', ')}`
).join('\n')}

## „Ç≥„É≥„ÉÜ„É≥„ÉÑÈñ¢ÈÄ£ÊÄß

${knowledgeMap.contentRelationships.map(rel => 
  `- ${rel.domain1} ‚Üî ${rel.domain2}: ${rel.relationship}`
).join('\n')}

## Áü•Ë≠ò„ÇØ„É©„Çπ„Çø„Éº

${knowledgeMap.knowledgeClusters.map(cluster => 
  `- **${cluster.clusterName}** (${cluster.clusterType})\n  - ‰∏≠Ê†∏Ê¶ÇÂøµ: ${cluster.centralConcept}\n  - Âº∑Â∫¶: ${cluster.strength}/10\n  - „É°„É≥„Éê„Éº: ${cluster.members.join('„ÄÅ')}`
).join('\n\n')}

---

*„Åì„ÅÆ„Éû„ÉÉ„Éó„ÅØÂÆüÈöõ„ÅÆ„É¥„Ç©„É´„ÉàÂÜÖÂÆπ„Åã„ÇâÁîüÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇÊßãÈÄ†Â§âÊõ¥ÊôÇ„ÅØ \`/init\` „ÅßÊõ¥Êñ∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ*
`;
  }
  
  /**
   * Generate English vault knowledge map
   */
  private generateEnglishKnowledgeMap(knowledgeMap: VaultKnowledgeMap, timestamp: string): string {
    return `---
created: ${knowledgeMap.generatedAt}
tags:
  - obsius
  - vault-knowledge
  - knowledge-structure
language: en
---

# Vault Knowledge Structure Map

*Generated ${timestamp}*

## Vault Overview

${knowledgeMap.vaultProfile}

## Folder Structure & Purpose

${knowledgeMap.folderStructure.map(folder => 
  `- **${folder.name}**: ${folder.purpose} (${folder.contentType})`
).join('\n')}

## Knowledge Domains

${knowledgeMap.knowledgeDomains.map(domain => 
  `- **${domain.name}**: ${domain.description}\n  - Path: \`${domain.folderPath}\``
).join('\n')}

## Usage Patterns

${knowledgeMap.usagePatterns.map(pattern => 
  `- **${pattern.pattern}**\n  - Evidence: ${pattern.evidence.join(', ')}`
).join('\n')}

## Content Relationships

${knowledgeMap.contentRelationships.map(rel => 
  `- ${rel.domain1} ‚Üî ${rel.domain2}: ${rel.relationship}`
).join('\n')}

## Knowledge Clusters

${knowledgeMap.knowledgeClusters.map(cluster => 
  `- **${cluster.clusterName}** (${cluster.clusterType})\n  - Central concept: ${cluster.centralConcept}\n  - Strength: ${cluster.strength}/10\n  - Members: ${cluster.members.join(', ')}`
).join('\n\n')}

---

*This map was generated from actual vault content. Update with \`/init\` when structure changes.*
`;
  }
  
  /**
   * Generate sophisticated knowledge clusters from enhanced analysis
   */
  private generateKnowledgeClusters(enhanced: any, language: string): VaultKnowledgeMap['knowledgeClusters'] {
    const clusters: VaultKnowledgeMap['knowledgeClusters'] = [];
    
    // Topic-based clustering
    clusters.push(...this.generateTopicClusters(enhanced, language));
    
    // Importance-based clustering  
    clusters.push(...this.generateImportanceClusters(enhanced, language));
    
    // Content type clustering
    clusters.push(...this.generateContentTypeClusters(enhanced, language));
    
    // Usage pattern clustering
    clusters.push(...this.generateUsagePatternClusters(enhanced, language));
    
    return clusters.slice(0, 8); // Limit to top 8 most meaningful clusters
  }
  
  /**
   * Generate topic-based clusters
   */
  private generateTopicClusters(enhanced: any, language: string): VaultKnowledgeMap['knowledgeClusters'] {
    const clusters: VaultKnowledgeMap['knowledgeClusters'] = [];
    const topicGroups = new Map<string, string[]>();
    
    // Group files by shared key topics
    for (const file of enhanced.representativeFiles) {
      const keyTopics = file.keyTopics || [];
      for (const topic of keyTopics.slice(0, 3)) { // Top 3 topics per file
        if (!topicGroups.has(topic)) {
          topicGroups.set(topic, []);
        }
        topicGroups.get(topic)!.push(file.path.split('/').pop() || file.path);
      }
    }
    
    // Create clusters for topics with multiple files
    for (const [topic, files] of topicGroups.entries()) {
      if (files.length >= 2) {
        const strength = Math.min(10, files.length * 2); // Strength based on file count
        clusters.push({
          clusterName: language === 'ja' ? `${topic}„Éà„Éî„ÉÉ„ÇØÁæ§` : `${topic} Topic Cluster`,
          clusterType: 'topic',
          members: files.slice(0, 5), // Limit to 5 members
          centralConcept: topic,
          strength
        });
      }
    }
    
    return clusters.slice(0, 3); // Top 3 topic clusters
  }
  
  /**
   * Generate importance-based clusters
   */
  private generateImportanceClusters(enhanced: any, language: string): VaultKnowledgeMap['knowledgeClusters'] {
    const clusters: VaultKnowledgeMap['knowledgeClusters'] = [];
    const files = enhanced.representativeFiles;
    
    // Group by importance ranges
    const highImportance = files.filter((f: any) => (f.importance || 0) >= 8);
    const mediumImportance = files.filter((f: any) => (f.importance || 0) >= 5 && (f.importance || 0) < 8);
    const coreImportance = files.filter((f: any) => (f.importance || 0) >= 9);
    
    if (coreImportance.length >= 2) {
      clusters.push({
        clusterName: language === 'ja' ? '‰∏≠Ê†∏Áü•Ë≠òÁæ§' : 'Core Knowledge Cluster',
        clusterType: 'importance',
        members: coreImportance.slice(0, 4).map((f: any) => f.path.split('/').pop() || f.path),
        centralConcept: language === 'ja' ? 'ÊúÄÈáçË¶Å„Ç≥„É≥„ÉÜ„É≥„ÉÑ' : 'Critical content',
        strength: 10
      });
    }
    
    if (highImportance.length >= 3) {
      clusters.push({
        clusterName: language === 'ja' ? 'ÈáçË¶ÅÂèÇËÄÉË≥áÊñôÁæ§' : 'High-Priority Reference Cluster',
        clusterType: 'importance', 
        members: highImportance.slice(0, 5).map((f: any) => f.path.split('/').pop() || f.path),
        centralConcept: language === 'ja' ? 'ÈáçË¶Å„Å™ÂèÇËÄÉË≥áÊñô' : 'Important reference materials',
        strength: 8
      });
    }
    
    return clusters;
  }
  
  /**
   * Generate content type clusters
   */
  private generateContentTypeClusters(enhanced: any, language: string): VaultKnowledgeMap['knowledgeClusters'] {
    const clusters: VaultKnowledgeMap['knowledgeClusters'] = [];
    const typeGroups = new Map<string, any[]>();
    
    // Group files by category
    for (const file of enhanced.representativeFiles) {
      const category = file.category || 'unknown';
      if (!typeGroups.has(category)) {
        typeGroups.set(category, []);
      }
      typeGroups.get(category)!.push(file);
    }
    
    // Create clusters for categories with multiple files
    for (const [category, files] of typeGroups.entries()) {
      if (files.length >= 2) {
        const avgImportance = files.reduce((sum, f) => sum + (f.importance || 0), 0) / files.length;
        const strength = Math.min(10, Math.round(avgImportance));
        
        clusters.push({
          clusterName: language === 'ja' ? `${category}„Ç≥„É≥„ÉÜ„É≥„ÉÑÁæ§` : `${category} Content Cluster`,
          clusterType: 'contentType',
          members: files.slice(0, 5).map(f => f.path.split('/').pop() || f.path),
          centralConcept: category,
          strength
        });
      }
    }
    
    return clusters.slice(0, 2); // Top 2 content type clusters
  }
  
  /**
   * Generate usage pattern clusters
   */
  private generateUsagePatternClusters(enhanced: any, language: string): VaultKnowledgeMap['knowledgeClusters'] {
    const clusters: VaultKnowledgeMap['knowledgeClusters'] = [];
    const characteristics = enhanced.vaultCharacteristics;
    
    // Cluster based on organization sophistication
    if (characteristics.organizationLevel === 'sophisticated') {
      const organizedFiles = enhanced.representativeFiles
        .filter((f: any) => (f.importance || 0) >= 6)
        .slice(0, 4);
        
      if (organizedFiles.length >= 2) {
        clusters.push({
          clusterName: language === 'ja' ? 'È´òÂ∫¶ÁµÑÁπîÂåñ„Ç≥„É≥„ÉÜ„É≥„ÉÑÁæ§' : 'Sophisticated Organization Cluster',
          clusterType: 'usage',
          members: organizedFiles.map((f: any) => f.path.split('/').pop() || f.path),
          centralConcept: language === 'ja' ? '‰ΩìÁ≥ªÁöÑÁü•Ë≠òÁÆ°ÁêÜ' : 'Systematic knowledge management',
          strength: 9
        });
      }
    }
    
    // Cluster based on knowledge depth
    if (characteristics.knowledgeDepth === 'deep') {
      const deepFiles = enhanced.representativeFiles
        .filter((f: any) => (f.keyTopics?.length || 0) >= 4)
        .slice(0, 3);
        
      if (deepFiles.length >= 2) {
        clusters.push({
          clusterName: language === 'ja' ? 'Ê∑±Â±§Áü•Ë≠òÁæ§' : 'Deep Knowledge Cluster',
          clusterType: 'usage',
          members: deepFiles.map((f: any) => f.path.split('/').pop() || f.path),
          centralConcept: language === 'ja' ? 'Â∞ÇÈñÄÁöÑÊ∑±Â±§Áü•Ë≠ò' : 'Specialized deep knowledge',
          strength: 8
        });
      }
    }
    
    return clusters;
  }
  
  /**
   * Generate basic knowledge clusters for fallback analysis
   */
  private generateBasicKnowledgeClusters(data: AnalysisData, language: string): VaultKnowledgeMap['knowledgeClusters'] {
    const clusters: VaultKnowledgeMap['knowledgeClusters'] = [];
    
    // Create clusters based on primary domains
    const domains = data.insights?.primaryDomains || [];
    for (let i = 0; i < Math.min(domains.length, 3); i++) {
      const domain = domains[i];
      clusters.push({
        clusterName: language === 'ja' ? `${domain}Áü•Ë≠òÁæ§` : `${domain} Knowledge Group`,
        clusterType: 'topic',
        members: [domain], // Limited information in basic analysis
        centralConcept: domain,
        strength: 6 // Moderate strength for basic clustering
      });
    }
    
    // Create folder-based cluster if significant content
    const folderCount = data.vaultStructure?.totalFolders || 0;
    if (folderCount > 5) {
      clusters.push({
        clusterName: language === 'ja' ? 'ÊßãÈÄ†ÂåñÁµÑÁπîÁæ§' : 'Structured Organization Group',
        clusterType: 'usage',
        members: language === 'ja' ? ['Ë§áÊï∞„Éï„Ç©„É´„ÉÄÊßãÈÄ†'] : ['Multi-folder structure'],
        centralConcept: language === 'ja' ? '„Éï„Ç©„É´„ÉÄ„Éô„Éº„ÇπÁµÑÁπî' : 'Folder-based organization',
        strength: 5
      });
    }
    
    return clusters;
  }
  
  private getPhaseNumber(): number {
    return 11; // Final phase in the workflow
  }
}